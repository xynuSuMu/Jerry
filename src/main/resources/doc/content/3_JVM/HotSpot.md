> 每一个Java进程都存在一个JVM的实例，我们的Java程序就是运行在JVM实例中

在前面几节我们聊到，Javac编译器将java文件编译为class文件后，由JVM将字节码转为与机器适配的机器码进行执行，
这里我们说的JVM实际上是JVM实例(**我们说的JVM通常有三种含义，一种是抽象规范，规范仅仅是个概念、一个具体的是实现，比如HotSpot、 一种是运行中的虚拟机实例**)，我们运行多个Java程序的时候，并不是所有Java程序共用一个JVM，而是每个应用
都有自己的JVM实例，我们的Java程序是运行在JVM实例中，所以JVM实例加上我们的Java程序叫做一个Java进程，每个Java进程中JVM实例是彼此隔离的。

而JVM实例对字节码执行的具体过程，就要从JVM的构成说起(这里说的JVM是抽象规范，具体实现要根据厂商的具体实现)。

以HotSpot为例，JVM的实现一共有三个子系统和两大组件，分别是：
类装载器（ClassLoader）子系统、执
行引擎子系统和GC子系统，组
件是内存运行数据区域和本地接口

各自的功能大致如下图：

![image](https://p3.pstatp.com/origin/pgc-image/fd3b629671b54e50a4d6f7cefcc26f23)

上图JVM的组成模块中，内存回收和运行时数据区可能是听闻最多的名词，因为它们是面试中高频面试点，涉及到新生代、老年代、元空间、垃圾回收策略等等，
而类装载子系统、执行引擎知名度就相对低了一些，类装载子系统可以理解为类加载器所形成的功能系统，执行引擎就是将字节码指令转为机器码执行的，当然如我们直接使用的本地方法，那么执行的方法就可以通过执行引擎进行翻译执行。

下面对于每个模块进行简要的介绍：

**类装载子系统**，它是负责查找并装载类型的，简单的说就是通过类加载器将.class文件加载到运行时数据区，
在JVM中类加载器有两类，一类启动类装载器，一类是用户自定义类装载器，装载的过程可分为三个部分：装载、连接、初始化。

装载的过程就好像对货物进行装运然后发车运到工厂，能在装运期间完成的工作就给他完成了(static变量赋默认值，初始化之类的)，
不能完成的就等待后面需要的时候再去完成。再细节一点的说，当我们在创建JVM实例后，
我们需要指定一个要执行的主类（包含 main() 方法的那个类），虚拟机会先**初始化**这个主类，
而其他类的加载时机不是固定的(实例化只是初始化的其中一部分)。，然后创建main线程来执行main函数，其分配私有的程序计数器，虚拟机栈，本地方法栈，这也是为什么在同一个类中静态代码块优于main函数先执行

**运行时数据区**，指的是Java程序运行所在的内存区域，这个区域被JVM所管理。并
分为不同的数据区域：方法区、堆、程序计数器、虚拟机栈、本地方法栈，因为在JDK8中
增加了元空间(**元空间是方法区概念的实现**)，其使用的是直接内存，所以直接内存也可以算作运行时数据区。
这些不同的模块分别都有各自用途，这里简单的聊一下，当class文件被加载到JVM的内存区域时，其类型信息被
存放到方法区中，而我们创建一个对象时，对象通常存放到堆中，虚拟机栈是一个线程的执行区域，
它保存着一个线程中的方法的调用状态，而如果当前线程执行的代码是C/C++写的本地代码，
那么就会存入本地方法栈，而程序计数器可以看做当前线程所执行的字节码的行号指示器。在虚拟机概念模型里，
字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，
分支，循环，跳转，异常处理，线程恢复等基础功能都需要依赖这个计数器来完成。

注：HotSpot实现中，虚拟机栈和本地方法栈已经合并在一起，不做区分，由-Xss参数设置栈大小

数据区就如一个工厂一样，方法区就类似档案库，里面对于每一件货物信息进行了的记录，而堆就是存放货物的仓库，
那么每个线程就是一张进货单，而虚拟机栈和本地方法栈就类似存着需要需要货物的顺序，程序计数器就记录每一个进货单目前的出库情况。


**执行引擎**，通常执行引擎需将字节码转换成可以直接被JVM执行的语言，执行引擎可以认为是JVM中最重要的一环，
因为它是执行程序的，我们运行中Java程序的每一个线程都是一个独立的虚拟机执行引擎的实例，通常有以下两种方式转换执行Java代码(或者混合模式执行)：

a. 解释器：一条一条的读取，解释并且执行字节码指令

b. 即时编译器：执行引擎首先按照解释执行的方式来执行，在合适的时候，即时编译器把整段字节码编译成本地代码。
内置了JIT编译器的JVM都会检查方法的执行频率，如果一个方法的执行频率超过一个特定的值的话，那么这个方法就会被编译成本地代码。

但是当执行引擎遇到遇到请求本地方法调用的指令时，着发起这个本 地方法调用，调用成功后执行引擎继续执行字节码流中的下一条指令，在上面的例子中，我们将虚拟机栈比做存着货物的容器，那么执行引擎的作用就是将进货单的物品从虚拟机栈中取出来，取的方式就有两种，就我们说的解释器和即使编译器，解释器就是边一边组装货物，一边装货，而编译器是一次性
组装好，后续直接进行装货，而无需组装。


**内存回收系统**，内存回收也是JVM面试中高频面试点，它的作用是对运行时数据区的内存进行管理，需要注意的是，
虚拟机栈、本地方法栈手不在内存回收的功能范围内，它主要是对于方法区(元空间)、堆进行内存管理。


这里对于各个功能做一个简单不细说类，后面的文章 会对于每一个模块进行详细的介绍。