#### 深度优先搜索

深度优先搜索每次沿着路径到达不能再前进时，退回到最近的岔道口向下继续遍历。

#### 实现过程

连通分量:在无向图中，如果两个顶点可以相互到达(可以通过一定路径间接到达)，那么陈这个两个顶点连通，如果图G中任意两个顶点都连通，则称图G为连通图，
否则称为非连通图，其中极大连通子图称为连通分量。

强连通分量:在有向图中，如果两个顶点可以各自通过一条有向路径到达另一顶点，就称这两个顶点强连通，如果图G任意两个顶点都能强连通，那么图G称为
强连通图，否则称为非强连通图，其中极大强连通子图称为强连通分量

可以知道如果遍历整个图，就需要对所有连通块(连通分量和强连通分量)进行遍历。基本思想就是在遍历的过程中，将经过的顶点设置为已遍历。

#### 实现代码(C++)

基于上一篇实现

```c++
//DFS顶点
void DFS(int v){
    //邻接表
    cout<<"到达顶点"<<v<<endl;
    visit[v]=1;
    //所有能到达的点
    
    for (int i=0; i<adj[v].size(); i++) {
        int temp = adj[v][i].v;
        if (visit[temp]==0) {
            DFS(temp);
        }
    }
}
//DFS图
void DFSTrave(vector<Node> g[maxV]){
    for (int i=0; i<maxV; i++) {
        if(!g[i].empty() &&visit[i]==0){
            DFS(i);
        }
    }
}
```








